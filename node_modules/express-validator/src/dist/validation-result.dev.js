"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Result = exports.validationResult = void 0;

var _ = require("lodash");

var base_1 = require("./base");

var utils_1 = require("./utils"); // Assign to a variable so that TS doesn't use its catch all overload, which returns any


var withWithDefaults = {
  withDefaults: withDefaults
};
exports.validationResult = Object.assign(withDefaults(), withWithDefaults);

var Result =
/*#__PURE__*/
function () {
  function Result(formatter, errors) {
    _classCallCheck(this, Result);

    this.formatter = formatter;
    this.errors = errors;
  }

  _createClass(Result, [{
    key: "array",
    value: function array(options) {
      return options && options.onlyFirstError ? Object.values(this.mapped()) : this.errors.map(this.formatter);
    }
  }, {
    key: "mapped",
    value: function mapped() {
      var _this = this;

      return this.errors.reduce(function (mapping, error) {
        if (!mapping[error.param]) {
          mapping[error.param] = _this.formatter(error);
        }

        return mapping;
      }, {});
    }
  }, {
    key: "formatWith",
    value: function formatWith(formatter) {
      return new Result(formatter, this.errors);
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this.errors.length === 0;
    }
  }, {
    key: "throw",
    value: function _throw() {
      if (!this.isEmpty()) {
        throw Object.assign(new Error(), utils_1.bindAll(this));
      }
    }
  }]);

  return Result;
}();

exports.Result = Result;

function withDefaults() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = {
    formatter: function formatter(error) {
      return error;
    }
  };

  var actualOptions = _.defaults(options, defaults);

  return function (req) {
    var contexts = req[base_1.contextsKey] || [];

    var errors = _.flatMap(contexts, 'errors');

    return new Result(actualOptions.formatter, errors);
  };
}